from fastapi import APIRouter, HTTPException, Depends
import uuid
from pydantic import BaseModel, Field, ValidationError, validator
import databutton as db
import requests # Keep for CF API calls
from typing import Dict, Any, Optional, List, Literal

from cryptography.fernet import Fernet, InvalidToken # Added for encryption
from app.auth import AuthorizedUser
import requests
import uuid
import secrets # For generating secure tokens
import re
import json # For JSON operations with worker metadata # For user identification
from app.apis.cloaking_orchestration_api import (
    get_main_config,
    save_main_config,
    ConfiguredDomainDetails, # For storing domain setup details
    CloudflareAccountStoredDetails # For CF account details
)
import re
from datetime import datetime, timezone
import json # For worker metadata

CLOUDFLARE_API_BASE_URL = "https://api.cloudflare.com/client/v4"
# This should be the user-specific Vercel deployment URL for their Phantom Shield instance
# or a generic endpoint that knows how to route based on user. For now, placeholder.
# Eventually, this needs to be dynamically determined or configurable per user/domain.
# PLATFORM_WORKER_DECISION_ENDPOINT = "https://<user-specific-phantom-shield-instance>.vercel.app/api/v1/cloaking/decide-route"
# For now, using the provided fixed IP as per user spec, though this is not scalable for SaaS
PLATFORM_WORKER_DECISION_ENDPOINT = "http://159.203.106.80:3000/decide-cloak" # Hardcoded as per user spec

ENCRYPTION_KEY_NAME = "PHANTOM_SHIELD_ENCRYPTION_KEY"

# Global variable for the cipher, initialized on first use by get_fernet_cipher()
_fernet_cipher: Optional[Fernet] = None

def get_fernet_cipher() -> Optional[Fernet]:
    """Retrieves the Fernet cipher, initializing it if necessary and if the key exists."""
    global _fernet_cipher
    if _fernet_cipher is None:
        encryption_key_value = db.secrets.get(ENCRYPTION_KEY_NAME)
        if not encryption_key_value:
            print(f"[CRITICAL ERROR] Secret '{ENCRYPTION_KEY_NAME}' is not set. Encryption/decryption will be unavailable.")
            return None
        try:
            _fernet_cipher = Fernet(encryption_key_value.encode())
            print("Fernet cipher initialized successfully.")
        except Exception as e:
            print(f"[CRITICAL ERROR] Failed to initialize Fernet cipher with key '{ENCRYPTION_KEY_NAME}': {e}. Encryption/decryption will fail.")
            return None
    return _fernet_cipher

def _encrypt_token(api_token: str) -> str:
    cipher = get_fernet_cipher()
    if not cipher:
        raise HTTPException(status_code=503, detail="Encryption service not available due to missing encryption key.")
    try:
        encrypted_token = cipher.encrypt(api_token.encode())
        return encrypted_token.decode()
    except Exception as e:
        print(f"Error encrypting token: {e}")
        raise HTTPException(status_code=500, detail=f"Failed to encrypt token: {str(e)}")

def _decrypt_token(encrypted_token: str) -> str:
    cipher = get_fernet_cipher()
    if not cipher:
        raise HTTPException(status_code=503, detail="Decryption service not available due to missing encryption key.")
    try:
        decrypted_token = cipher.decrypt(encrypted_token.encode())
        return decrypted_token.decode()
    except InvalidToken as e_invalid:
        print(f"Error: Invalid token during decryption for token starting with: {encrypted_token[:10]}...")
        raise HTTPException(status_code=400, detail="Invalid encrypted token. Decryption failed.") from e_invalid
    except Exception as e_general:
        print(f"An unexpected error occurred during decryption: {e_general}")
        raise HTTPException(status_code=500, detail=f"An unexpected error occurred during decryption: {str(e_general)}") from e_general

# Worker Script Template
# KV_NAMESPACE will be bound to the specific KV namespace for this domain/user during worker deployment.
# WORKER_AUTH_TOKEN will be a unique token generated by our platform for this worker instance.
# CLOAK_ENDPOINT will be the Phantom Shield backend endpoint for decision making.
GENERIC_WORKER_SCRIPT_TEMPLATE = """
// KV_NAMESPACE, WORKER_AUTH_TOKEN, and CLOAK_ENDPOINT are expected to be bound to the worker environment
// For local testing, you might mock these or use wrangler.toml secrets.

addEventListener('fetch', event => {
  event.respondWith(handleRequest(event.request));
});

async function handleRequest(request) {
  if (!CLOAK_ENDPOINT || !WORKER_AUTH_TOKEN || !KV_NAMESPACE) {
    console.error("Worker bindings (CLOAK_ENDPOINT, WORKER_AUTH_TOKEN, KV_NAMESPACE) are not configured.");
    return new Response("Worker configuration error. Please contact support.", { status: 503, headers: { 'Content-Type': 'text/plain' } });
  }
  const url = new URL(request.url);
  const clientIp = request.headers.get('cf-connecting-ip');
  const userAgent = request.headers.get('user-agent');
  const country = request.headers.get('cf-ipcountry');

  const requestDetails = {
    host: url.host, // The domain the user accessed, e.g., yourdomain.com
    path: url.pathname, // The path part, e.g., /campanha1
    method: request.method,
    headers: { // Forward relevant headers
      'user-agent': userAgent,
      'cf-ipcountry': country,
      'cf-connecting-ip': clientIp,
      'referer': request.headers.get('referer'),
      'accept-language': request.headers.get('accept-language'),
      // Add other headers you deem necessary for filtering
    },
    queryString: url.search, // e.g., ?param1=value1
    // Potentially add more details if needed by the decision endpoint
  };

  try {
    const controller = new AbortController();
    const timeoutId = setTimeout(() => controller.abort(), 5000); // 5-second timeout

    const backendResponse = await fetch(CLOAK_ENDPOINT, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'X-Worker-Auth-Token': WORKER_AUTH_TOKEN // Secure communication with your backend
      },
      body: JSON.stringify(requestDetails),
      signal: controller.signal // For timeout
    });
    clearTimeout(timeoutId);

    if (!backendResponse.ok) {
      let errorDetails = `Backend decision error: ${backendResponse.status}`;
      try {
        const errorData = await backendResponse.json();
        errorDetails += ` - ${errorData.detail || JSON.stringify(errorData)}`;
      } catch (e) { /* ignore if error response is not JSON */ }
      console.error(errorDetails);
      // Attempt to serve a generic white page from KV as a fallback
      const fallbackContent = await KV_NAMESPACE.get(`default_white_page:${url.host}`); // Domain-specific default
      if (fallbackContent) {
        return new Response(fallbackContent, { headers: { 'Content-Type': 'text/html' } });
      }
      return new Response('Access Denied - System Error', { status: 403, headers: { 'Content-Type': 'text/plain' } });
    }

    const decision = await backendResponse.json(); // Expects { action: "serve_html" | "proxy_external_url", content: "...", content_type: "..." }

    if (decision.action === 'serve_html') {
      return new Response(decision.content, { headers: { 'Content-Type': decision.content_type || 'text/html' } });
    } else if (decision.action === 'proxy_external_url') {
      // Basic proxy logic, can be enhanced
      // Ensure the target URL is valid
      let targetUrl;
      try {
        targetUrl = new URL(decision.content);
      } catch (e) {
        console.error("Invalid URL provided by backend for proxying:", decision.content);
        return new Response("Proxy configuration error.", { status: 500 });
      }
      
      // Create new headers for the proxied request, removing Cloudflare-specific ones
      const proxyHeaders = new Headers(request.headers);
      ['cf-connecting-ip', 'cf-ipcountry', 'cf-ray', 'cf-visitor', 'cdn-loop'].forEach(h => proxyHeaders.delete(h));
      proxyHeaders.set('Host', targetUrl.host); // Set the correct Host header for the target origin
      proxyHeaders.set('X-Forwarded-For', clientIp || ''); // Optionally add X-Forwarded-For
      proxyHeaders.set('X-Forwarded-Proto', url.protocol.slice(0, -1));

      const externalResponse = await fetch(targetUrl.toString(), {
          method: request.method, // Use original method
          headers: proxyHeaders,
          body: (request.method !== 'GET' && request.method !== 'HEAD') ? request.body : undefined, // Include body for relevant methods
          redirect: 'manual' // Do not follow redirects from the origin automatically
      });

      // If the external resource redirects, we might not want to follow it to prevent uncloaking.
      // This decision can be made more sophisticated (e.g., only allow redirects within the same external domain)
      if (externalResponse.status >= 300 && externalResponse.status < 400) {
        console.warn(\`Proxied content from ${targetUrl.toString()} attempted redirect to: ${externalResponse.headers.get('Location')}. Redirect blocked.\`);
        return new Response('Cloaked content redirection is not supported by default.', { status: 403, headers: { 'Content-Type': 'text/html' } });
      }

      const responseHeaders = new Headers(externalResponse.headers);
      // Remove headers that might leak info or cause issues, like Set-Cookie from the proxied site
      responseHeaders.delete('Set-Cookie'); 
      // Add any custom headers if needed, e.g., 'X-Cloaked-By: PhantomShield'
      
      return new Response(externalResponse.body, {
        status: externalResponse.status,
        statusText: externalResponse.statusText,
        headers: responseHeaders
      });
    } else {
      console.error('Invalid action from backend:', decision.action);
      return new Response('Invalid configuration from backend.', { status: 500, headers: { 'Content-Type': 'text/plain' } });
    }

  } catch (error) {
    console.error('Error in Worker handling request:', error.message, error.stack);
    // Fallback to a generic white page on any unhandled error
    const fallbackContent = await KV_NAMESPACE.get(`default_white_page:${url.host}`);
    if (fallbackContent) {
      return new Response(fallbackContent, { headers: { 'Content-Type': 'text/html' } });
    }
    return new Response('Cloaking System Error - Please try again later.', { status: 503, headers: { 'Content-Type': 'text/plain' } });
  }
}
"""

router = APIRouter(prefix="/domain-management", tags=["Domain Management"])

class CheckEncryptionResponse(BaseModel):
    message: str
    has_key: bool

@router.get("/check-encryption-key", response_model=CheckEncryptionResponse, summary="Check if Encryption Key is Set")
async def check_encryption_key_status(user: AuthorizedUser):
    print(f"User {user.sub} checking encryption key status.")
    cipher = get_fernet_cipher()
    if cipher:
        return CheckEncryptionResponse(message="Encryption key is set and Fernet cipher initialized.", has_key=True)
    else:
        if not db.secrets.get(ENCRYPTION_KEY_NAME):
            return CheckEncryptionResponse(message=f"Encryption key '{ENCRYPTION_KEY_NAME}' is NOT SET in secrets!", has_key=False)
        else:
            return CheckEncryptionResponse(message=f"Encryption key '{ENCRYPTION_KEY_NAME}' is set, but Fernet cipher initialization FAILED. Check server logs.", has_key=False)

class CloudflareAccountAddRequest(BaseModel):
    account_identifier: str = Field(..., description="A user-friendly name or email to identify this Cloudflare account configuration.")
    api_token_value: str = Field(..., description="The actual Cloudflare API token value.")

class CloudflareAccountAddResponse(BaseModel):
    account_storage_key: str
    identifier: str
    status: str
    message: str

class CloudflareAccountListItem(BaseModel):
    account_storage_key: str
    identifier: str
    status: str

class ListCloudflareAccountsResponse(BaseModel):
    accounts: list[CloudflareAccountListItem]

class ConfigureDomainRequest(BaseModel):
    cloudflare_account_db_id: str
    domain_name: str

class ConfigureDomainResponse(BaseModel):
    success: bool
    message: str
    domain_name: Optional[str] = None
    nameservers: Optional[List[str]] = None
    zone_id: Optional[str] = None
    worker_script_name: Optional[str] = None
    kv_namespace_id: Optional[str] = None
    cname_setup_status: Optional[Literal["success", "failed", "skipped", "exists", "not_applicable"]] = "not_applicable"
    worker_deployed_status: Optional[Literal["success", "failed", "skipped", "exists"]] = "skipped"
    worker_route_status: Optional[Literal["success", "failed", "skipped", "exists"]] = "skipped"
    txt_verification_hostname: Optional[str] = None
    txt_verification_token: Optional[str] = None
    overall_status: Literal["pending_txt_verification", "pending_nameserver_update", "active", "configuration_failed", "error"] = "error"

class RequestDomainVerificationRequest(BaseModel):
    domain_name: str = Field(..., description="The domain name to request TXT verification for.")
    cloudflare_account_db_id: str = Field(..., description="The storage key of the Cloudflare account to use for this domain.")

class RequestDomainVerificationResponse(BaseModel):
    message: str
    domain_name: str
    txt_verification_hostname: Optional[str] = None
    txt_verification_token: Optional[str] = None
    status: Literal["pending_txt_verification", "already_verified", "error", "zone_not_found_in_cf", "cf_account_error"]

class ConfirmDomainVerificationRequest(BaseModel):
    domain_name: str = Field(..., description="The domain name to confirm TXT verification for.")
    cloudflare_account_db_id: str

class ConfirmDomainVerificationResponse(BaseModel):
    success: bool
    message: str
    domain_name: str
    status: Literal["verified_and_configured", "verified_configuration_pending", "verification_failed", "error", "already_active", "zone_not_found_in_cf", "cf_account_error"]
    nameservers: Optional[List[str]] = None
    zone_id: Optional[str] = None
    worker_script_name: Optional[str] = None
    kv_namespace_id: Optional[str] = None


@router.post("/add-cloudflare-account", response_model=CloudflareAccountAddResponse, summary="Add and Verify Cloudflare Account Token")
async def add_cloudflare_account(req_data: CloudflareAccountAddRequest, user: AuthorizedUser):
    print(f"User {user.sub}: Attempting to add/verify Cloudflare account: {req_data.account_identifier} using direct API token value.")
    if not get_fernet_cipher():
        raise HTTPException(status_code=503, detail=f"Encryption service unavailable. Ensure '{ENCRYPTION_KEY_NAME}' secret is set.")

    actual_api_token = req_data.api_token_value.strip()
    if not actual_api_token:
        raise HTTPException(status_code=400, detail="API token value cannot be empty.")

    verify_url = f"{CLOUDFLARE_API_BASE_URL}/user/tokens/verify"
    headers = {"Authorization": f"Bearer {actual_api_token}", "Content-Type": "application/json"}
    print(f"User {user.sub}: Sending to CF verify. Auth header starts with: {headers.get('Authorization', '')[:15]}...")
    
    verification_status = "verification_failed"
    cf_token_id_from_token: Optional[str] = None
    cf_account_id_from_token_scope: Optional[str] = None
    verification_error_message: Optional[str] = None
    original_exception_for_verification: Optional[Exception] = None

    try:
        response = requests.get(verify_url, headers=headers, timeout=10)
        print(f"User {user.sub}: Cloudflare token verification response status: {response.status_code} for account {req_data.account_identifier}")
        if response.status_code == 200:
            verification_data = response.json()
            if verification_data.get("success") and verification_data.get("result", {}).get("status") == "active":
                verification_status = "verified"
                cf_token_id_from_token = verification_data.get("result", {}).get("id")
                print(f"User {user.sub}: Token for {req_data.account_identifier} verified. Token ID: {cf_token_id_from_token}")
                
                accounts_url = f"{CLOUDFLARE_API_BASE_URL}/accounts"
                accounts_response = requests.get(accounts_url, headers=headers, timeout=10)
                if accounts_response.status_code == 200:
                    accounts_data = accounts_response.json()
                    if accounts_data.get("success") and accounts_data.get("result") and len(accounts_data["result"]) > 0:
                        # Assuming the token is primarily for one main account, or the first one listed.
                        # More robust logic might be needed if a token can manage many accounts and user needs to pick.
                        cf_account_id_from_token_scope = accounts_data["result"][0].get("id")
                        print(f"User {user.sub}: Fetched Cloudflare Account ID: {cf_account_id_from_token_scope} for {req_data.account_identifier}")
                    else:
                        print(f"User {user.sub}: Could not determine Cloudflare Account ID for {req_data.account_identifier} from /accounts. May need Account.Read permission for the token. Response: {accounts_response.text[:200]}")
                else:
                    print(f"User {user.sub}: Failed to fetch /accounts for {req_data.account_identifier}. Status: {accounts_response.status_code}, Body: {accounts_response.text[:200]}. cf_account_id may be undetermined.")
            else:
                error_detail = verification_data.get("errors", [{}])[0] if verification_data.get("errors") else {}
                verification_error_message = error_detail.get("message", "Token is not active or invalid.")
                print(f"User {user.sub}: Token verification failed for {req_data.account_identifier}: {verification_error_message}")
        else:
            try:
                error_content = response.json()
                error_detail = error_content.get("errors", [{}])[0] if error_content.get("errors") else {}
                verification_error_message = error_detail.get("message", f"Cloudflare API error ({response.status_code}).")
            except Exception:
                verification_error_message = f"Cloudflare API error ({response.status_code}): {response.text[:200]}"
            print(f"User {user.sub}: Token verification HTTP error for {req_data.account_identifier}: {verification_error_message}")
    except requests.exceptions.RequestException as e_req:
        print(f"User {user.sub}: Requests Exception during token verification for {req_data.account_identifier}: {e_req}")
        verification_error_message = f"Network error: {str(e_req)}"
        original_exception_for_verification = e_req
    except Exception as e_general:
        print(f"User {user.sub}: Unexpected error during token verification for {req_data.account_identifier}: {e_general}")
        verification_error_message = f"Unexpected error: {str(e_general)}"
        original_exception_for_verification = e_general

    main_config_dict: Dict[str, Any] = get_main_config()
    account_storage_key = re.sub(r'[^a-z0-9_]+', '_', req_data.account_identifier.lower().strip()).strip('_')
    if not account_storage_key:
        timestamp_slug = str(datetime.now(timezone.utc).timestamp()).replace('.', '_')
        account_storage_key = f"cf_account_{timestamp_slug}"
    
    encrypted_api_token = _encrypt_token(actual_api_token)

    account_details = CloudflareAccountStoredDetails(
        identifier=req_data.account_identifier,
        api_token_secret_key_encrypted=encrypted_api_token,
        status=verification_status,
        added_by=user.sub,
        added_at=datetime.now(timezone.utc).isoformat(),
        cf_account_id=cf_account_id_from_token_scope,
        cf_token_id=cf_token_id_from_token,
        last_verification_attempt=datetime.now(timezone.utc).isoformat(),
        last_verification_error=verification_error_message
    )
    
    cf_accounts_dict = main_config_dict.setdefault("cloudflare_accounts", {})
    cf_accounts_dict[account_storage_key] = account_details.model_dump()
    save_main_config(main_config_dict)
    
    print(f"User {user.sub}: Cloudflare account '{req_data.account_identifier}' (key: {account_storage_key}) config saved with status: {verification_status}")

    if verification_status == "verified":
        return CloudflareAccountAddResponse(
            account_storage_key=account_storage_key,
            identifier=req_data.account_identifier,
            status="verified",
            message="Cloudflare account token verified and configuration saved successfully."
        )
    else:
        final_message = f"Cloudflare account configuration saved, but token verification failed: {verification_error_message or 'Unknown verification error.'}"
        raise HTTPException(status_code=400, detail=final_message) from original_exception_for_verification

@router.get("/list-cloudflare-accounts", response_model=ListCloudflareAccountsResponse, summary="List Added Cloudflare Accounts")
async def list_cloudflare_accounts(user: AuthorizedUser):
    print(f"User {user.sub}: Attempting to list Cloudflare accounts.")
    try:
        main_config_dict = get_main_config()
        accounts_list = []
        cf_accounts_dict = main_config_dict.get("cloudflare_accounts")
        if cf_accounts_dict:
            for storage_key, account_dict_data in cf_accounts_dict.items():
                identifier = "N/A"
                status = "unknown"
                try:
                    parsed_model = CloudflareAccountStoredDetails(**account_dict_data)
                    identifier = parsed_model.identifier
                    status = parsed_model.status
                except ValidationError as e_val:
                    print(f"User {user.sub}: Validation error parsing CloudflareAccountStoredDetails for key {storage_key}: {e_val}. Data: {account_dict_data}")
                    identifier = account_dict_data.get("identifier", "N/A (validation error)")
                    status = account_dict_data.get("status", "error")
                except Exception as e_parse_generic:
                    print(f"User {user.sub}: Generic error parsing CloudflareAccountStoredDetails for key {storage_key}: {e_parse_generic}. Data: {account_dict_data}")
                    identifier = account_dict_data.get("identifier", "N/A (parsing error)")
                    status = account_dict_data.get("status", "error")
                
                accounts_list.append(
                    CloudflareAccountListItem(
                        account_storage_key=storage_key,
                        identifier=identifier,
                        status=status
                    )
                )
        print(f"User {user.sub}: Found {len(accounts_list)} Cloudflare accounts.")
        return ListCloudflareAccountsResponse(accounts=accounts_list)
    except Exception as e:
        print(f"User {user.sub}: Error listing Cloudflare accounts: {e}")
        raise HTTPException(status_code=500, detail=f"Failed to list Cloudflare accounts: {str(e)}") from e

def _generate_txt_verification_details(domain_name: str) -> tuple[str, str]:
    token_part = uuid.uuid4().hex[:16] # Shorter token for TXT value
    hostname = f"_phantomshield-verify.{domain_name}"
    token_value = f"phantomshield-token={token_part}"
    return hostname, token_value

@router.post("/request-domain-txt-verification", response_model=RequestDomainVerificationResponse, summary="Request TXT Record for Domain Verification")
async def request_domain_txt_verification(req_data: RequestDomainVerificationRequest, user: AuthorizedUser):
    print(f"User {user.sub}: Requesting TXT verification for domain: {req_data.domain_name} using CF account DB ID: {req_data.cloudflare_account_db_id}")
    main_config = get_main_config()
    cf_accounts = main_config.get("cloudflare_accounts", {})
    domain_configs = main_config.get("configured_domains", {})

    if req_data.cloudflare_account_db_id not in cf_accounts:
        raise HTTPException(status_code=404, detail=f"Cloudflare account DB ID '{req_data.cloudflare_account_db_id}' not found.")
    
    cf_account_model = CloudflareAccountStoredDetails(**cf_accounts[req_data.cloudflare_account_db_id])
    if cf_account_model.status != "verified" or not cf_account_model.cf_account_id:
        return RequestDomainVerificationResponse(
            message="Cloudflare account is not verified or Cloudflare Account ID is missing.",
            domain_name=req_data.domain_name,
            status="cf_account_error"
        )

    domain_name_norm = req_data.domain_name.lower().strip()
    domain_config = domain_configs.get(domain_name_norm)

    if domain_config:
        domain_model = ConfiguredDomainDetails(**domain_config)
        if domain_model.status == "active":
            return RequestDomainVerificationResponse(
                message=f"Domain '{domain_name_norm}' is already active and configured.",
                domain_name=domain_name_norm,
                status="already_verified"
            )
        if domain_model.txt_verification_hostname and domain_model.txt_verification_token and domain_model.status == "pending_txt_verification":
            return RequestDomainVerificationResponse(
                message="TXT verification already pending. Use the previously provided details.",
                domain_name=domain_name_norm,
                txt_verification_hostname=domain_model.txt_verification_hostname,
                txt_verification_token=domain_model.txt_verification_token,
                status="pending_txt_verification"
            )
    
    # Generate new TXT details
    txt_hostname, txt_token = _generate_txt_verification_details(domain_name_norm)
    
    if not domain_config:
        domain_config_data = ConfiguredDomainDetails(
            domain_name=domain_name_norm,
            cloudflare_account_storage_key=req_data.cloudflare_account_db_id,
            status="pending_txt_verification",
            txt_verification_hostname=txt_hostname,
            txt_verification_token=txt_token,
            last_configured_at=datetime.now(timezone.utc).isoformat()
        )
        domain_configs[domain_name_norm] = domain_config_data.model_dump()
    else: # Update existing pending/failed config
        domain_config["status"] = "pending_txt_verification"
        domain_config["txt_verification_hostname"] = txt_hostname
        domain_config["txt_verification_token"] = txt_token
        domain_config["last_error_message"] = None # Clear previous errors
        domain_config["cf_zone_id"] = None # Reset as zone might not exist or not be verified yet
        domain_config["nameservers"] = None
        domain_config["cf_kv_namespace_id"] = None
        domain_config["cf_worker_script_name"] = None
        domain_config["app_worker_auth_token"] = None

    main_config["configured_domains"] = domain_configs
    save_main_config(main_config)

    return RequestDomainVerificationResponse(
        message=f"TXT verification requested. Add TXT record for {txt_hostname} with value '{txt_token}'.",
        domain_name=domain_name_norm,
        txt_verification_hostname=txt_hostname,
        txt_verification_token=txt_token,
        status="pending_txt_verification"
    )

async def _get_cf_api_token_and_account_id(cf_account_db_id: str, main_config: Dict[str, Any]) -> tuple[str, str]:
    """Helper to get decrypted token and CF account ID."""
    cf_accounts = main_config.get("cloudflare_accounts", {})
    if cf_account_db_id not in cf_accounts:
        raise HTTPException(status_code=404, detail=f"Cloudflare account DB ID '{cf_account_db_id}' not found.")
    
    account_data = cf_accounts[cf_account_db_id]
    try:
        cf_account_model = CloudflareAccountStoredDetails(**account_data)
    except ValidationError as e_val:
        raise HTTPException(status_code=500, detail=f"Invalid Cloudflare account data for {cf_account_db_id}: {e_val}")

    if cf_account_model.status != "verified" or not cf_account_model.cf_account_id:
        raise HTTPException(status_code=400, detail=f"Cloudflare account '{cf_account_model.identifier}' is not verified or CF Account ID is missing.")
    
    if not get_fernet_cipher():
        raise HTTPException(status_code=503, detail="Encryption service unavailable.")
    
    try:
        decrypted_token = _decrypt_token(cf_account_model.api_token_secret_key_encrypted)
    except HTTPException as e_decrypt: # Propagate decryption specific errors
        raise e_decrypt
        
    return decrypted_token, cf_account_model.cf_account_id

async def _verify_txt_record_on_cloudflare(
    domain_name: str, 
    txt_hostname: str, 
    expected_txt_value: str, 
    cf_api_token: str
) -> bool:
    """Checks Cloudflare DNS for the specific TXT record. This is more reliable than public DNS due to propagation delays."""
    # First, find the zone ID for the domain_name
    headers = {"Authorization": f"Bearer {cf_api_token}", "Content-Type": "application/json"}
    list_zones_url = f"{CLOUDFLARE_API_BASE_URL}/zones"
    params = {"name": domain_name, "status": "active,pending"} # Check active or pending zones
    
    try:
        response = requests.get(list_zones_url, headers=headers, params=params, timeout=10)
        response.raise_for_status()
        zones_data = response.json()
        
        cf_zone_id = None
        if zones_data.get("success") and zones_data.get("result"):
            for zone in zones_data["result"]:
                if zone["name"] == domain_name:
                    cf_zone_id = zone["id"]
                    break
        
        if not cf_zone_id:
            print(f"TXT Verify: Zone for {domain_name} not found on Cloudflare account.")
            return False # Zone doesn't exist on this CF account yet, so TXT can't be verified there.

        # Now check for the TXT record within that zone
        dns_records_url = f"{CLOUDFLARE_API_BASE_URL}/zones/{cf_zone_id}/dns_records"
        # Note: 'name' for DNS API is the full hostname of the record.
        dns_params = {"type": "TXT", "name": txt_hostname, "content": expected_txt_value, "match": "all"} 
        
        dns_response = requests.get(dns_records_url, headers=headers, params=dns_params, timeout=10)
        dns_response.raise_for_status()
        dns_data = dns_response.json()

        if dns_data.get("success") and dns_data.get("result"):
            for record in dns_data["result"]:
                # Double check, though API params should ensure this
                if record.get("name", "").lower() == txt_hostname.lower() and record.get("content") == expected_txt_value:
                    print(f"TXT Verify: Record {txt_hostname} with value '{expected_txt_value}' FOUND via Cloudflare API for zone {cf_zone_id}.")
                    return True
        print(f"TXT Verify: Record {txt_hostname} with value '{expected_txt_value}' NOT FOUND via Cloudflare API for zone {cf_zone_id}. Params: {dns_params}, Response: {dns_data.get('result_info')}")
        return False
    except requests.exceptions.RequestException as e:
        print(f"Cloudflare API request error during TXT verification for {txt_hostname}: {e}")
        return False
    except Exception as e_gen:
        print(f"Unexpected error during Cloudflare TXT verification for {txt_hostname}: {e_gen}")
        return False

async def _configure_cloudflare_resources_after_verification(
    domain_model: ConfiguredDomainDetails,
    cf_api_token: str,
    cf_account_id_real: str, # The actual Cloudflare account ID
    main_config_ref: Dict[str, Any], # To save updates
    user_sub: str
) -> ConfiguredDomainDetails:
    """
    Sets up Cloudflare Zone (if not existing or pending), KV, Worker, DNS after TXT verification.
    Modifies and returns the domain_model. Saves main_config_ref.
    """
    print(f"User {user_sub}: Starting Cloudflare resource configuration for verified domain: {domain_model.domain_name}")
    common_headers = {"Authorization": f"Bearer {cf_api_token}", "Content-Type": "application/json"}
    domain_name_norm = domain_model.domain_name # Already normalized

    # --- 1. Zone Management (Ensure exists and get ID) ---
    cf_zone_id = domain_model.cf_zone_id
    cf_nameservers = domain_model.nameservers
    zone_created_or_found = False

    if not cf_zone_id: # If we don't have a zone ID from a previous step (e.g. TXT check found it)
        list_zones_url = f"{CLOUDFLARE_API_BASE_URL}/zones"
        params = {"name": domain_name_norm, "account.id": cf_account_id_real, "status": "active,pending"}
        try:
            response = requests.get(list_zones_url, headers=common_headers, params=params, timeout=10)
            response.raise_for_status()
            zones_data = response.json()
            existing_zone = None
            if zones_data.get("success") and zones_data.get("result"):
                for zone in zones_data["result"]:
                    if zone["name"] == domain_name_norm:
                        existing_zone = zone
                        break
            if existing_zone:
                cf_zone_id = existing_zone["id"]
                cf_nameservers = existing_zone.get("name_servers")
                domain_model.cf_zone_id = cf_zone_id
                domain_model.nameservers = cf_nameservers
                if existing_zone["status"] == "active":
                    domain_model.status_detail_message = f"Zone '{domain_name_norm}' already exists and is active."
                    print(domain_model.status_detail_message)
                else: # pending
                    domain_model.status = "pending_nameserver_update" # If zone exists but pending
                    domain_model.status_detail_message = f"Zone '{domain_name_norm}' exists (status: {existing_zone['status']}). Update nameservers: {', '.join(cf_nameservers or [])}."
                    print(domain_model.status_detail_message)
                zone_created_or_found = True
            else: # Create Zone
                create_zone_url = f"{CLOUDFLARE_API_BASE_URL}/zones"
                payload = {"name": domain_name_norm, "account": {"id": cf_account_id_real}, "type": "full"}
                response_create = requests.post(create_zone_url, headers=common_headers, json=payload, timeout=15)
                response_create.raise_for_status()
                created_zone_data = response_create.json()
                if created_zone_data.get("success") and created_zone_data.get("result"):
                    new_zone = created_zone_data["result"]
                    cf_zone_id = new_zone["id"]
                    cf_nameservers = new_zone.get("name_servers")
                    domain_model.cf_zone_id = cf_zone_id
                    domain_model.nameservers = cf_nameservers
                    domain_model.status = "pending_nameserver_update"
                    domain_model.status_detail_message = f"Zone '{domain_name_norm}' created. Update nameservers: {', '.join(cf_nameservers or [])}."
                    print(domain_model.status_detail_message)
                    zone_created_or_found = True
                else:
                    err_msg = created_zone_data.get("errors", [{}])[0].get("message", "Zone creation failed.")
                    domain_model.last_error_message = f"CF Zone creation: {err_msg}"
                    domain_model.status = "configuration_failed"
                    print(f"Error: {domain_model.last_error_message}")
                    main_config_ref["configured_domains"][domain_name_norm] = domain_model.model_dump()
                    save_main_config(main_config_ref)
                    return domain_model # Early exit
        except requests.exceptions.RequestException as e:
            domain_model.last_error_message = f"CF Zone management error: {e}"
            domain_model.status = "configuration_failed"
            print(f"Error: {domain_model.last_error_message}")
            main_config_ref["configured_domains"][domain_name_norm] = domain_model.model_dump()
            save_main_config(main_config_ref)
            return domain_model # Early exit
    else: # We had a zone ID already, assume it's still valid for now
        print(f"Zone {domain_name_norm} (ID: {cf_zone_id}) was previously identified. Proceeding.")
        zone_created_or_found = True
        # Ensure status reflects we might still need NS update if not active
        # This logic could be more nuanced if we re-checked the zone status here.
        # For now, if cf_zone_id exists, assume it's at least 'pending' or 'active'.
        # If it was 'pending_txt_verification' and we have a zone_id, it means TXT check passed for an existing zone.
        # If that zone is 'pending', it should become 'pending_nameserver_update'
        # If that zone is 'active', then NS are fine.
        # This part is a bit tricky without re-fetching zone status explicitly *here* based on existing cf_zone_id.
        # Let's assume if cf_zone_id is present and TXT was verified, the zone is at least 'pending'.
        if domain_model.status == "pending_txt_verification" and cf_zone_id: # After TXT verification for an existing zone
            # Check current status of this existing zone
            zone_details_url = f"{CLOUDFLARE_API_BASE_URL}/zones/{cf_zone_id}"
            try:
                zone_resp = requests.get(zone_details_url, headers=common_headers, timeout=10)
                zone_resp.raise_for_status()
                zone_data = zone_resp.json()
                if zone_data.get("success") and zone_data["result"]["status"] == "active":
                    print(f"Zone {domain_name_norm} (ID: {cf_zone_id}) is active.")
                    # No change to domain_model.status needed if it implies active already
                else: # pending or other
                    domain_model.status = "pending_nameserver_update"
                    domain_model.nameservers = zone_data.get("result", {}).get("name_servers", domain_model.nameservers)
                    print(f"Zone {domain_name_norm} (ID: {cf_zone_id}) is {zone_data.get('result', {}).get('status', 'unknown')}. Nameservers: {domain_model.nameservers}")
            except Exception as e_zone_check:
                print(f"Could not re-verify status for existing zone {cf_zone_id}: {e_zone_check}")
                # Proceed with caution, or mark as error
                # domain_model.status = "configuration_failed" 
                # domain_model.last_error_message = f"Failed to re-verify status of existing zone {cf_zone_id}"


    if not zone_created_or_found or not cf_zone_id: # Should not happen if logic above is correct
        domain_model.last_error_message = "Failed to create or find Cloudflare Zone."
        domain_model.status = "configuration_failed"
        print(f"Error: {domain_model.last_error_message}")
        main_config_ref["configured_domains"][domain_name_norm] = domain_model.model_dump()
        save_main_config(main_config_ref)
        return domain_model
    
    # At this point, domain_model.status might be 'pending_nameserver_update' or imply active if zone was already active.
    # If it's 'pending_nameserver_update', we cannot proceed with Worker routes that depend on active zone.
    # However, we *can* create KV and deploy the worker script itself.
    # The DNS CNAME record for '*' can also be added even if zone is pending.

    # --- 2. KV Namespace ---
    kv_namespace_title = f"ps_kv_{re.sub(r'[^a-zA-Z0-9-]', '_', domain_name_norm)[:45]}"
    cf_kv_namespace_id = domain_model.cf_kv_namespace_id
    if not cf_kv_namespace_id:
        list_kv_url = f"{CLOUDFLARE_API_BASE_URL}/accounts/{cf_account_id_real}/storage/kv/namespaces"
        try:
            response_kv_list = requests.get(list_kv_url, headers=common_headers, timeout=10)
            response_kv_list.raise_for_status()
            kv_list_data = response_kv_list.json()
            existing_kv = next((ns for ns in kv_list_data.get("result", []) if ns.get("title") == kv_namespace_title), None)
            if existing_kv:
                cf_kv_namespace_id = existing_kv["id"]
                domain_model.status_detail_message += f" | KV Namespace '{kv_namespace_title}' (ID: {cf_kv_namespace_id}) already exists."
            else:
                create_kv_url = f"{CLOUDFLARE_API_BASE_URL}/accounts/{cf_account_id_real}/storage/kv/namespaces"
                kv_payload = {"title": kv_namespace_title}
                response_kv_create = requests.post(create_kv_url, headers=common_headers, json=kv_payload, timeout=10)
                response_kv_create.raise_for_status()
                kv_create_data = response_kv_create.json()
                if kv_create_data.get("success") and kv_create_data.get("result", {}).get("id"):
                    cf_kv_namespace_id = kv_create_data["result"]["id"]
                    domain_model.status_detail_message += f" | KV Namespace '{kv_namespace_title}' (ID: {cf_kv_namespace_id}) created."
                else:
                    err_msg = kv_create_data.get("errors", [{}])[0].get("message", "KV creation failed.")
                    domain_model.last_error_message = (domain_model.last_error_message or "") + f" | CF KV creation: {err_msg}"
                    # Not making this a fatal error for overall status yet, worker can be deployed without binding initially
            domain_model.cf_kv_namespace_id = cf_kv_namespace_id
            print(domain_model.status_detail_message.split("|")[-1].strip()) # Log the KV part
        except requests.exceptions.RequestException as e:
            domain_model.last_error_message = (domain_model.last_error_message or "") + f" | CF KV error: {e}"
            print(f"Error managing KV: {e}")
    else:
        print(f"KV Namespace {domain_model.cf_kv_namespace_id} previously configured for {domain_name_norm}.")

    # --- 3. Worker Script Deployment ---
    worker_script_name_base = f"ps_worker_{re.sub(r'[^a-z0-9]', '_', domain_name_norm)[:30]}"
    # Append a short hash of user_sub to ensure uniqueness if multiple users configure same domain name (though domain should be unique to an account)
    # Or better, use a UUID for true uniqueness or rely on CF account scoping.
    # For now, keeping it simpler:
    worker_script_name = f"{worker_script_name_base}_{uuid.uuid4().hex[:6]}" # Ensures unique worker name
    
    app_worker_auth_token = domain_model.app_worker_auth_token or uuid.uuid4().hex # Generate if not exists
    domain_model.app_worker_auth_token = app_worker_auth_token

    worker_content = GENERIC_WORKER_SCRIPT_TEMPLATE # Already defined globally
    
    # Metadata for bindings:
    # https://developers.cloudflare.com/workers/wrangler/configuration/#bindings
    bindings = [
        {"type": "secret_text", "name": "WORKER_AUTH_TOKEN", "text": app_worker_auth_token},
        {"type": "secret_text", "name": "CLOAK_ENDPOINT", "text": PLATFORM_WORKER_DECISION_ENDPOINT}
    ]
    if cf_kv_namespace_id: # Only add KV binding if KV namespace was successfully created/found
        bindings.append({"type": "kv_namespace", "name": "KV_NAMESPACE", "namespace_id": cf_kv_namespace_id})
    else:
        print(f"Warning: KV Namespace ID not available for {domain_name_norm}. Worker will be deployed without KV_NAMESPACE binding initially.")
        domain_model.status_detail_message += " | Worker deployed without KV binding (KV setup issue)."
        # This might require worker update later if KV is created after initial deploy.

    # The multipart request structure for worker deployment:
    # https://developers.cloudflare.com/api/operations/worker-script-upload-worker
    # One part is 'script' (the code), another is 'metadata' (JSON string with bindings).
    
    worker_script_upload_url = f"{CLOUDFLARE_API_BASE_URL}/accounts/{cf_account_id_real}/workers/scripts/{worker_script_name}"
    
    # We need to use `files` for multipart/form-data with `requests`
    # The metadata needs to be a string, so `json.dumps`
    files_payload = {
        'script': (None, worker_content, 'application/javascript+module'), # For ES Modules format
        'metadata': (None, json.dumps({"bindings": bindings, "main_module": "script.js"}), 'application/json') # script.js is a dummy name
    }
    # Headers for PUT request for worker script (multipart/form-data is set by requests library)
    # No, Content-Type should not be application/json for multipart
    worker_headers = {"Authorization": f"Bearer {cf_api_token}"} # requests will set multipart Content-Type

    try:
        print(f"Deploying worker script {worker_script_name} for {domain_name_norm} with bindings: {json.dumps(bindings)}")
        response_worker = requests.put(worker_script_upload_url, headers=worker_headers, files=files_payload, timeout=20)
        response_worker.raise_for_status() # Check for HTTP errors
        worker_data = response_worker.json()
        if worker_data.get("success"):
            domain_model.cf_worker_script_name = worker_script_name
            domain_model.worker_deployed_status = "success"
            domain_model.status_detail_message += f" | Worker '{worker_script_name}' deployed."
            print(f"Worker script {worker_script_name} deployed successfully for {domain_name_norm}.")
            
            # --- 4. Worker Route (if zone is active) ---
            current_zone_status_for_route = None
            # Re-verify zone status before attempting to create routes
            if cf_zone_id: # We must have a zone ID
                zone_details_url = f"{CLOUDFLARE_API_BASE_URL}/zones/{cf_zone_id}"
                try:
                    zone_stat_resp = requests.get(zone_details_url, headers=common_headers, timeout=10)
                    zone_stat_resp.raise_for_status()
                    current_zone_status_for_route = zone_stat_resp.json().get("result",{}).get("status")
                    if current_zone_status_for_route == "active":
                        domain_model.zone_status = "active" # Update our record
                        domain_model.status_detail_message += " | Zone confirmed active."
                    else:
                        domain_model.zone_status = current_zone_status_for_route
                        domain_model.status_detail_message += f" | Zone status: {current_zone_status_for_route}. Routes will not be created until active."
                except requests.exceptions.RequestException as e_zone_stat:
                    print(f"Error re-checking zone status for {cf_zone_id}: {e_zone_stat}")
                    domain_model.status_detail_message += " | Could not re-verify zone status for routing."
                    # Proceed with assumption it might not be active
            
            if current_zone_status_for_route == "active":
                domain_model.status_detail_message += " | Attempting to configure worker routes."
                route_patterns_to_ensure = [
                    f"*.{domain_name_norm}/*", # Wildcard for all subdomains and paths
                    f"{domain_name_norm}/*"    # Apex domain and paths
                ]
                all_routes_configured = True
                route_creation_errors = []

                for route_pattern in route_patterns_to_ensure:
                    try:
                        list_routes_url = f"{CLOUDFLARE_API_BASE_URL}/zones/{cf_zone_id}/workers/routes"
                        routes_resp = requests.get(list_routes_url, headers=common_headers, params={'pattern': route_pattern}, timeout=10)
                        routes_resp.raise_for_status()
                        
                        route_exists_for_script = False
                        existing_routes_data = routes_resp.json().get("result", [])
                        for r in existing_routes_data:
                            if r.get("pattern") == route_pattern:
                                if r.get("script") == worker_script_name:
                                    route_exists_for_script = True
                                    print(f"Route {route_pattern} to script {worker_script_name} already exists.")
                                    break
                                else: # Route exists but for a different script, need to update (or delete and recreate)
                                    # For simplicity, we'll try to delete and recreate if script is different.
                                    # More advanced: update script if possible. For now, this is robust.
                                    print(f"Route {route_pattern} exists but for different script '{r.get('script')}'. Will replace.")
                                    delete_route_url = f"{CLOUDFLARE_API_BASE_URL}/zones/{cf_zone_id}/workers/routes/{r['id']}"
                                    del_resp = requests.delete(delete_route_url, headers=common_headers, timeout=10)
                                    del_resp.raise_for_status()
                                    print(f"Deleted old route {r['id']} for pattern {route_pattern}.")
                                    break # Break to allow recreation in the next step
                        
                        if not route_exists_for_script:
                            create_route_url = f"{CLOUDFLARE_API_BASE_URL}/zones/{cf_zone_id}/workers/routes"
                            route_payload = {"pattern": route_pattern, "script": worker_script_name, "enabled": True}
                            response_route = requests.post(create_route_url, headers=common_headers, json=route_payload, timeout=15)
                            response_route.raise_for_status()
                            route_create_data = response_route.json()
                            if route_create_data.get("success"):
                                print(f"Route {route_pattern} successfully created for script {worker_script_name}.")
                            else:
                                err_msg = route_create_data.get("errors", [{}])[0].get("message", f"Failed to create route {route_pattern}")
                                route_creation_errors.append(err_msg)
                                print(f"Error creating route {route_pattern}: {err_msg}")
                                all_routes_configured = False
                    except requests.exceptions.RequestException as e_route:
                        err_msg = f"API error configuring route {route_pattern}: {str(e_route)}"
                        route_creation_errors.append(err_msg)
                        print(err_msg)
                        all_routes_configured = False
                
                if all_routes_configured:
                    domain_model.worker_route_status = "configured"
                    domain_model.status_detail_message += " | All worker routes configured."
                    domain_model.status = "active" # This is the full success state
                else:
                    domain_model.worker_route_status = "failed"
                    error_summary = "; ".join(route_creation_errors)
                    domain_model.status_detail_message += f" | Failed to configure some worker routes: {error_summary}"
                    domain_model.last_error_message = (domain_model.last_error_message or "") + f" | Route errors: {error_summary}"
                    domain_model.status = "configuration_failed" # Mark as failed if routes are critical
            
            elif domain_model.cf_worker_script_name: # Worker deployed but zone not active
                domain_model.status = "pending_nameserver_update"
                domain_model.worker_route_status = "pending_zone_activation"
                domain_model.status_detail_message += f" | Worker deployed. Routes pending: zone status is '{current_zone_status_for_route or domain_model.zone_status}'. Update nameservers: {', '.join(domain_model.nameservers or [])}."
            else: # Worker not deployed, should not reach here normally if previous steps guard it
                domain_model.status = "configuration_failed"
                domain_model.status_detail_message += " | Worker script not deployed. Cannot configure routes."
                domain_model.worker_route_status = "pending_worker_deployment"

        else: # Worker deployment failed
            err_msg = worker_data.get("errors", [{}])[0].get("message", "Worker deployment to CF failed.")
            domain_model.last_error_message = (domain_model.last_error_message or "") + f" | CF Worker deployment: {err_msg}"
            domain_model.worker_deployed_status = "failed"
            domain_model.status = "configuration_failed"
            domain_model.status_detail_message += f" | Worker deployment failed: {err_msg}"
            print(f"Error: {domain_model.last_error_message}")

    except requests.exceptions.RequestException as e_worker_deploy:
        error_text = e_worker_deploy.response.text if e_worker_deploy.response else "No response data"
        domain_model.last_error_message = (domain_model.last_error_message or "") + f" | CF Worker API error: {str(e_worker_deploy)} - {error_text[:200]}"
        domain_model.worker_deployed_status = "failed"
        domain_model.status = "configuration_failed"
        domain_model.status_detail_message += f" | Worker deployment API error: {str(e_worker_deploy)}"
        print(f"Error: {domain_model.last_error_message}")
    except Exception as e_generic_worker:
        domain_model.last_error_message = (domain_model.last_error_message or "") + f" | Generic error during worker deployment: {str(e_generic_worker)}"
        domain_model.worker_deployed_status = "failed"
        domain_model.status = "configuration_failed"
        domain_model.status_detail_message += f" | Worker deployment generic error: {str(e_generic_worker)}"
        print(f"Error: {domain_model.last_error_message}")

    # --- Final Save and Return --- 
    main_config_ref["configured_domains"][domain_name_norm] = domain_model.model_dump(exclude_none=True)
    save_main_config(main_config_ref)
    print(f"Final status for {domain_name_norm}: {domain_model.status}, Details: {domain_model.status_detail_message}")
    return domain_model

                    if response_route.status_code == 200 and response_route.json().get("success"):
                        domain_model.worker_route_status = "success"
                        domain_model.status_detail_message += f" | Worker route '{route_pattern}' to '{worker_script_name}' created."
                        print(f"Worker route {route_pattern} created successfully for {domain_name_norm}.")
                    else:
                        err_msg = response_route.json().get("errors", [{}])[0].get("message", "Route creation failed.") if response_route.status_code != 200 else "Route creation succeeded but API format unexpected."
                        if response_route.status_code == 409 or (response_route.status_code == 400 and "already exists" in err_msg.lower()): # Conflict or specific error
                             domain_model.worker_route_status = "exists"
                             print(f"Route {route_pattern} to {worker_script_name} already exists (caught by error).")
                        else:
                            domain_model.worker_route_status = "failed"
                            domain_model.last_error_message = (domain_model.last_error_message or "") + f" | CF Worker Route: {err_msg} (Status: {response_route.status_code})"
                            print(f"Failed to create worker route for {domain_name_norm}: {err_msg} (Status: {response_route.status_code})")
            else: # Zone not active, skip route creation
                domain_model.worker_route_status = "skipped"
                domain_model.status_detail_message += f" | Worker route skipped (Zone status: {current_zone_status_for_route or 'unknown'}). Requires active zone."
                print(f"Worker route creation skipped for {domain_name_norm} as zone is not active (status: {current_zone_status_for_route or 'unknown'}).")

        else: # Worker deployment failed
            err_msg = worker_data.get("errors", [{}])[0].get("message", "Worker deployment failed.")
            domain_model.worker_deployed_status = "failed"
            domain_model.last_error_message = (domain_model.last_error_message or "") + f" | CF Worker Deploy: {err_msg}"
            print(f"Failed to deploy worker script for {domain_name_norm}: {err_msg}")
            # If worker deploy failed, route status is also effectively failed or skipped
            domain_model.worker_route_status = "skipped" if domain_model.worker_deployed_status == "failed" else domain_model.worker_route_status


    except requests.exceptions.HTTPError as e_http: # Catch HTTP errors from CF API specifically
        error_body = ""
        try:
            error_body = e_http.response.json() if e_http.response else "No response body"
        except json.JSONDecodeError:
            error_body = e_http.response.text if e_http.response else "No response text"
        domain_model.last_error_message = (domain_model.last_error_message or "") + f" | CF Worker HTTP error: {e_http}. Body: {error_body}"
        domain_model.worker_deployed_status = "failed"
        print(f"Cloudflare API HTTP error during worker deployment for {domain_name_norm}: {e_http}. Response: {error_body}")
    except requests.exceptions.RequestException as e_req: # Catch other request exceptions (network, timeout)
        domain_model.last_error_message = (domain_model.last_error_message or "") + f" | CF Worker Request error: {e_req}"
        domain_model.worker_deployed_status = "failed"
        print(f"Network/Request error during worker deployment for {domain_name_norm}: {e_req}")
    except Exception as e_gen: # Catch any other general errors
        domain_model.last_error_message = (domain_model.last_error_message or "") + f" | CF Worker General error: {e_gen}"
        domain_model.worker_deployed_status = "failed"
        print(f"Unexpected error during worker deployment for {domain_name_norm}: {e_gen}")

    # --- 5. Final Status Update ---
    if domain_model.last_error_message:
        domain_model.status = "configuration_failed"
    elif domain_model.status == "pending_nameserver_update": # If it's still pending NS after all attempts
        pass # Keep this status
    elif domain_model.worker_deployed_status == "success" and (domain_model.worker_route_status == "success" or domain_model.worker_route_status == "exists"):
        domain_model.status = "active"
        domain_model.status_detail_message += " | Domain is active and configured."
    else: # Other intermediate states or partial successes leading to non-active
        domain_model.status = "configuration_failed" # Default to failed if not clearly active or pending NS
        if not domain_model.last_error_message: # if no specific error, provide generic one
            domain_model.last_error_message = "Configuration completed with warnings or partial failures. Review details."
        domain_model.status_detail_message += " | Configuration requires review."
    
    print(f"Final status for {domain_name_norm}: {domain_model.status}. Details: {domain_model.status_detail_message}. Errors: {domain_model.last_error_message}")
    
    domain_model.last_configured_at = datetime.now(timezone.utc).isoformat()
    main_config_ref["configured_domains"][domain_name_norm] = domain_model.model_dump()
    save_main_config(main_config_ref)
    return domain_model


# @router.post("/confirm-domain-txt-verification", response_model=ConfirmDomainVerificationResponse, summary="Confirm Domain Verification via TXT Record and Configure")
# async def confirm_domain_txt_verification(req_data: ConfirmDomainVerificationRequest, user: AuthorizedUser):
    print(f"User {user.sub}: Confirming TXT verification for domain: {req_data.domain_name} using CF Account ID: {req_data.cloudflare_account_db_id}")
    main_config = get_main_config()
    domain_name_norm = req_data.domain_name.lower().strip()
    
    domain_configs = main_config.get("configured_domains", {})
    if domain_name_norm not in domain_configs:
        raise HTTPException(status_code=404, detail=f"Domain '{domain_name_norm}' not found or TXT verification not requested.")
    
    domain_model = ConfiguredDomainDetails(**domain_configs[domain_name_norm])

    if domain_model.status == "active":
        return ConfirmDomainVerificationResponse(success=True, message="Domain already active.", domain_name=domain_name_norm, status="already_active", zone_id=domain_model.cf_zone_id, nameservers=domain_model.nameservers, worker_script_name=domain_model.cf_worker_script_name, kv_namespace_id=domain_model.cf_kv_namespace_id)
    
    if domain_model.status != "pending_txt_verification" or not domain_model.txt_verification_hostname or not domain_model.txt_verification_token:
        raise HTTPException(status_code=400, detail=f"Domain '{domain_name_norm}' is not awaiting TXT verification or TXT details are missing. Current status: {domain_model.status}")

    # Get CF token and account ID
    try:
        cf_api_token, cf_account_id_real = await _get_cf_api_token_and_account_id(req_data.cloudflare_account_db_id, main_config)
    except HTTPException as e_auth: # Propagate auth/config errors for the CF account
        return ConfirmDomainVerificationResponse(success=False, message=f"Cloudflare Account Error: {e_auth.detail}", domain_name=domain_name_norm, status="cf_account_error")

    # Verify TXT record
    txt_verified = await _verify_txt_record_on_cloudflare(
        domain_name=domain_name_norm,
        txt_hostname=domain_model.txt_verification_hostname,
        expected_txt_value=domain_model.txt_verification_token,
        cf_api_token=cf_api_token
    )

    if not txt_verified:
        domain_model.last_error_message = f"TXT record '{domain_model.txt_verification_hostname}' with value '{domain_model.txt_verification_token}' not found or not propagated yet."
        domain_model.status_detail_message = "TXT verification failed."
        domain_configs[domain_name_norm] = domain_model.model_dump()
        save_main_config(main_config)
        return ConfirmDomainVerificationResponse(success=False, message=domain_model.last_error_message, domain_name=domain_name_norm, status="verification_failed")

    print(f"TXT record verified for {domain_name_norm}. Proceeding with Cloudflare resource configuration.")
    domain_model.status_detail_message = "TXT record verified."
    
    # Proceed with full configuration
    try:
        updated_domain_model = await _configure_cloudflare_resources_after_verification(
            domain_model=domain_model,
            cf_api_token=cf_api_token,
            cf_account_id_real=cf_account_id_real,
            main_config_ref=main_config, # Pass the whole main_config dict
            user_sub=user.sub
        )
    except HTTPException as e_config_http: # Catch HTTP exceptions from the config function
        return ConfirmDomainVerificationResponse(success=False, message=f"Configuration Error: {e_config_http.detail}", domain_name=domain_name_norm, status="error")
    except Exception as e_config_general: # Catch other unexpected errors
        print(f"Unexpected general error during _configure_cloudflare_resources_after_verification: {e_config_general}")
        return ConfirmDomainVerificationResponse(success=False, message=f"Unexpected server error during configuration: {str(e_config_general)}", domain_name=domain_name_norm, status="error")


    final_status_map = {
        "active": "verified_and_configured",
        "pending_nameserver_update": "verified_configuration_pending", # Needs NS update
        "configuration_failed": "error", # Generic error if config failed
    }
    response_status = final_status_map.get(updated_domain_model.status, "error")

    return ConfirmDomainVerificationResponse(
        success=updated_domain_model.status == "active" or updated_domain_model.status == "pending_nameserver_update", # Success if active or pending NS
        message=updated_domain_model.status_detail_message or "Configuration process completed.",
        domain_name=domain_name_norm,
        status=response_status,
        nameservers=updated_domain_model.nameservers,
        zone_id=updated_domain_model.cf_zone_id,
        worker_script_name=updated_domain_model.cf_worker_script_name,
        kv_namespace_id=updated_domain_model.cf_kv_namespace_id
    )


# Deprecated, use TXT verification flow
# @router.post("/configure-domain", response_model=ConfigureDomainResponse, tags=["Domain Management"], summary="[DEPRECATED] Configure Domain (use TXT flow)", deprecated=True)
# async def configure_domain_endpoint(request_data: ConfigureDomainRequest, user: AuthorizedUser):
    raise HTTPException(status_code=410, detail="This endpoint is deprecated. Please use the TXT verification flow: /request-domain-txt-verification and /confirm-domain-txt-verification.")

# Ensuring no stray code beyond this point that might cause import errors.
# The APIRouter named 'router' should be discoverable by the FastAPI app.


